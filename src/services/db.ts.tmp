import { DB_NAME } from './config'

class DatabaseProvider {
    private dbVersion: number

    constructor(dbName: string) {
        this.db = {}
        this.dbVersion = 1
        this.stores = { TODOS: 'todos' }
        this.init(dbName)
    }

    init(dbName: string) {
        const request = window.indexedDB.open(dbName, this.dbVersion)

        request.onupgradeneeded = () => {
            this.db = request.result
            this.createTodosStore()
        }

        request.onsuccess = event => (this.db = event.target.result)
        request.onerror = error => console.error({ error })
    }

    createTodosStore = () => {
        const storeConfig = { keyPath: 'id', autoIncrement: true }
        const objectStore = this.db.createObjectStore(
            this.stores.TODOS,
            storeConfig,
        )
        objectStore.createIndex('name', 'name')
        objectStore.createIndex('completed', 'completed')
    }

    getTodosObjectStore = () => {
        const transaction = this.db.transaction(
            [this.stores.TODOS],
            'readwrite',
        )
        transaction.oncomplete = () => this.db.close()
        transaction.onerror = error =>
            console.error('There was a transaction error', { error })
        return transaction.objectStore(this.stores.TODOS)
    }

    add = name => {
        return new Promise((resolve, reject) => {
            const objectStore = this.getTodosObjectStore()
            const addRequest = objectStore.put({ name, completed: false })
            addRequest.onsuccess = response => resolve(response)
            addRequest.onerror = error => reject(error)
        })
    }

    updateById = (id, newValue) => {
        return new Promise((resolve, reject) => {
            const objectStore = this.getTodosObjectStore()
            const keyRange = IDBKeyRange.only(id)
            const cursor = objectStore.openCursor(keyRange)

            cursor.onsuccess = () => {
                const cursorWithValue = cursor.result
                const { value } = cursorWithValue

                const updateTo = { ...value, ...newValue }
                const update = cursorWithValue.update(updateTo)
                update.onsuccess = res => resolve(res)
                update.onerror = err => reject(err)
            }

            cursor.onerror = error =>
                console.log('Item on check error', { error })
        })
    }

    deleteById = id => {
        return new Promise((resolve, reject) => {
            const objectStore = this.getTodosObjectStore()
            const deleting = objectStore.delete(id)
            deleting.onsuccess = response => resolve(response)
            deleting.onerror = error => reject(error)
        })
    }

    getAll = () => {
        return new Promise((resolve, reject) => {
            const objectStore = this.getTodosObjectStore()
            const openCursor = objectStore.openCursor()
            const items = []

            openCursor.onsuccess = event => {
                const cursor = event.target.result
                if (cursor) {
                    items.push(cursor.value)
                    cursor.continue()
                } else {
                    resolve(items)
                }
            }

            openCursor.onerror = error => reject(error)
        })
    }

    getById = id => {
        return new Promise((resolve, reject) => {
            const objectStore = this.getTodosObjectStore()
            const request = objectStore.get(id)
            request.onsuccess = () =>
                request.result ? resolve(request.result) : reject('Not found')
            request.onerror = error => reject(error)
        })
    }
}

export const DatabaseService = new DatabaseProvider(DB_NAME)
